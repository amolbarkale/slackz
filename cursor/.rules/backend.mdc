---
description: 
globs: 
alwaysApply: true
---
Supabase Setup & Configuration
Create Supabase Project

Sign in to Supabase and create a new project (select a region closest to your user base).

Enable the following services:

Auth

Database (Postgres)

Storage

Realtime

Retrieve API Keys & URLs

In the Supabase dashboard, note down:

SUPABASE_URL

SUPABASE_ANON_KEY

SERVICE_ROLE_KEY (for any server-side logic)

Enable Extensions

Using Supabase SQL Editor, run:

sql
Copy
Edit
-- Enable pgcrypto for UUID generation
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
(Future / Phase 2): Reserve pgvector for AI features, but do not enable it for MVP.

Configure Environment Variables

In your frontend (React) environment (e.g., .env.local):

ini
Copy
Edit
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key
In any serverless/Edge Function environment:

ini
Copy
Edit
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
Enable Row-Level Security (RLS)

For every table created below, immediately enable RLS and define policies.

This ensures strict, row-level data isolation by workspace_id (and user_id where applicable).

Authentication & Authorization
Supabase Auth (Email/Password)
Sign-Up Flow (Client)

Frontend calls:

js
Copy
Edit
await supabase.auth.signUp({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Post-Sign-Up Trigger (Edge Function or Postgres Trigger) automatically:

Inserts a new row into workspaces (using a provided workspace_name).

Inserts a new row into users linking auth.users.id → users.auth_id, assigning workspace_id.

Sign-In Flow (Client)

js
Copy
Edit
const { user, session, error } = await supabase.auth.signIn({
  email: "alice@example.com",
  password: "StrongPassword123"
});
On success, fetch the corresponding users row to retrieve workspace_id and other profile details.

Fetch User Profile (Client)

js
Copy
Edit
const { data: profile, error } = await supabase
  .from("users")
  .select("id, full_name, email, workspace_id, avatar_url")
  .eq("auth_id", supabase.auth.user().id)
  .single();
Returns the users table row for the signed-in user.

Authorization (“Single Role: user”)
All authenticated users share the same “user” role.

Authorization is enforced via RLS policies on every table, ensuring that users can only read/write rows where workspace_id matches their own and (where relevant) user_id = their own user ID.

Database Schema Design
Naming conventions

Tables and columns: lowercase with underscores.

UUID primary keys generated by gen_random_uuid().

Timestamps: created_at TIMESTAMPTZ DEFAULT now().

Each table includes workspace_id for scoping.

Below are all tables, with columns, constraints, indexes, and RLS policies.

1. Table: workspaces
sql
Copy
Edit
CREATE TABLE public.workspaces (
  id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  name        TEXT         NOT NULL UNIQUE,
  created_by  UUID         NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at  TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;

-- Policy: Allow a user to insert a workspace only if they are the creator
CREATE POLICY insert_workspace ON public.workspaces
  FOR INSERT
  WITH CHECK ( auth.uid() = created_by );

-- Policy: Allow a user to select their own workspace
CREATE POLICY select_workspace ON public.workspaces
  FOR SELECT
  USING ( auth.uid() = created_by );
Columns

id (UUID, PK)

name (TEXT, unique)

created_by (UUID → auth.users.id)

created_at (TIMESTAMPTZ)

RLS

Only the user whose auth_id matches created_by can insert or select.

2. Table: users
sql
Copy
Edit
CREATE TABLE public.users (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_id       UUID         NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name     TEXT         NOT NULL,
  email         TEXT         NOT NULL,
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  avatar_url    TEXT,
  created_at    TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Policy: Allow a user to select only their own profile
CREATE POLICY select_self_user ON public.users
  FOR SELECT
  USING ( auth.uid() = auth_id );

-- Policy: Allow a user to insert only if they are creating their own record
CREATE POLICY insert_user ON public.users
  FOR INSERT
  WITH CHECK ( auth.uid() = auth_id );

-- Policy: Allow a user to update only their own profile
CREATE POLICY update_self_user ON public.users
  FOR UPDATE
  USING ( auth.uid() = auth_id )
  WITH CHECK ( auth.uid() = auth_id );
Columns

id (UUID, PK)

auth_id (UUID → auth.users.id, unique)

full_name (TEXT)

email (TEXT)

workspace_id (UUID → workspaces.id)

avatar_url (TEXT, nullable)

created_at (TIMESTAMPTZ)

RLS

Users can only read/insert/update their own row (via auth_id).

3. Table: channels
sql
Copy
Edit
CREATE TABLE public.channels (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  name          TEXT         NOT NULL,
  description   TEXT,
  created_by    UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  created_at    TIMESTAMPTZ  NOT NULL DEFAULT now(),
  UNIQUE (workspace_id, name)
);

-- Enable RLS
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select channels only in their workspace
CREATE POLICY select_channels ON public.channels
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert a channel only if it belongs to their workspace
CREATE POLICY insert_channels ON public.channels
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to update channels only in their workspace
CREATE POLICY update_channels ON public.channels
  FOR UPDATE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  )
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete channels only in their workspace
CREATE POLICY delete_channels ON public.channels
  FOR DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

name (TEXT, unique per workspace)

description (TEXT, nullable)

created_by (UUID → users.id)

created_at (TIMESTAMPTZ)

Indexes

Unique index on (workspace_id, name).

RLS

All selects/inserts/updates/deletes restricted to the user’s own workspace.

4. Table: messages
sql
Copy
Edit
CREATE TABLE public.messages (
  id                UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id      UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  channel_id        UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  parent_message_id UUID         REFERENCES public.messages(id) ON DELETE CASCADE,
  user_id           UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  content           TEXT         NOT NULL,
  created_at        TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Indexes for fast lookups
CREATE INDEX idx_messages_channel_created_at
  ON public.messages (channel_id, created_at ASC);

CREATE INDEX idx_threads_parent_created_at
  ON public.messages (parent_message_id, created_at ASC);

-- Enable RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select messages only in their workspace
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert messages only if they belong to their workspace and user_id matches
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to update or delete only their own messages in their workspace
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

channel_id (UUID → channels.id)

parent_message_id (UUID → messages.id, nullable)

user_id (UUID → users.id)

content (TEXT)

created_at (TIMESTAMPTZ)

Indexes

(channel_id, created_at) for channel-ordered fetches.

(parent_message_id, created_at) for thread lookups.

RLS

All operations scoped to user’s workspace; only the message owner can update/delete.

5. Table: attachments
sql
Copy
Edit
CREATE TABLE public.attachments (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  channel_id    UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  message_id    UUID         NOT NULL REFERENCES public.messages(id) ON DELETE CASCADE,
  storage_path  TEXT         NOT NULL,
  filename      TEXT         NOT NULL,
  uploaded_by   UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  uploaded_at   TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Index for fast message-attachment lookups
CREATE INDEX idx_attachments_message
  ON public.attachments (message_id);

-- Enforce filetype (PDF or TXT) at DB level
ALTER TABLE public.attachments
  ADD CONSTRAINT chk_attachment_filetype
    CHECK ( filename ILIKE '%.pdf' OR filename ILIKE '%.txt' );

-- Enable RLS
ALTER TABLE public.attachments ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select attachments only in their workspace
CREATE POLICY select_attachments ON public.attachments
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert attachments only if workspace_id matches and uploader is themselves
CREATE POLICY insert_attachments ON public.attachments
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND uploaded_by = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete attachments only if they uploaded them and it’s their workspace
CREATE POLICY delete_attachments ON public.attachments
  FOR DELETE
  USING (
    uploaded_by = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

channel_id (UUID → channels.id)

message_id (UUID → messages.id)

storage_path (TEXT)

filename (TEXT, must end in .pdf or .txt)

uploaded_by (UUID → users.id)

uploaded_at (TIMESTAMPTZ)

Index

On message_id for quick lookups.

RLS

Only workspace members can insert/select; only uploader can delete.

6. Table: user_channel_reads
sql
Copy
Edit
CREATE TABLE public.user_channel_reads (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  user_id       UUID         NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  channel_id    UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  last_read_at  TIMESTAMPTZ  NOT NULL DEFAULT now(),
  UNIQUE (user_id, channel_id)
);

-- Enable RLS
ALTER TABLE public.user_channel_reads ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select their own read status only in their workspace
CREATE POLICY select_reads ON public.user_channel_reads
  FOR SELECT
  USING (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to upsert (insert/update) their own read status only in their workspace
CREATE POLICY upsert_reads ON public.user_channel_reads
  FOR INSERT, UPDATE
  WITH CHECK (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete their own read status only in their workspace
CREATE POLICY delete_reads ON public.user_channel_reads
  FOR DELETE
  USING (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

user_id (UUID → users.id)

channel_id (UUID → channels.id)

last_read_at (TIMESTAMPTZ)

Constraints

Unique composite key (user_id, channel_id).

RLS

Only workspace members can insert/select/update/delete their own rows.

API Endpoints & Documentation
Most “endpoints” in a Supabase-powered backend are handled via the Supabase Client (REST or JS SDK). Below is a logical mapping of front-end actions to Supabase calls, with clear request/response shapes.

Important: All client requests must include a valid Supabase session/token. RLS policies will enforce authorization.

1. Authentication Endpoints
Sign Up

Client Call (JS SDK):

js
Copy
Edit
const { user, session, error } = await supabase.auth.signUp({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Side Effects (via DB Trigger or Edge Function):

Create a new workspaces row using provided workspace_name.

Create a new users row with:

auth_id = auth.user().id

email = auth.user().email

full_name = provided full_name

workspace_id = newly created workspace.id

Response (Client):

jsonc
Copy
Edit
{
  "user": { /* auth.user() object */ },
  "session": { /* Supabase session object */ },
  "error": null
}
Common Errors:

400 Bad Request: Missing or invalid email/password.

409 Conflict: Workspace name already exists.

Sign In

Client Call:

js
Copy
Edit
const { user, session, error } = await supabase.auth.signIn({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Response:

jsonc
Copy
Edit
{
  "user": { /* auth.user() object */ },
  "session": { /* Supabase session object */ },
  "error": null
}
Common Errors:

400 Bad Request: Missing credentials.

401 Unauthorized: Incorrect email/password.

Fetch User Profile

Client Call:

js
Copy
Edit
const { data: profile, error } = await supabase
  .from("users")
  .select("id, full_name, email, workspace_id, avatar_url")
  .eq("auth_id", supabase.auth.user().id)
  .single();
Response:

jsonc
Copy
Edit
{
  "id": "user-uuid-123",
  "full_name": "Alice Johnson",
  "email": "alice@example.com",
  "workspace_id": "workspace-uuid-456",
  "avatar_url": null
}
Common Errors:

404 Not Found: No user row found (should not happen if triggers are correct).

2. Workspace Endpoints
Fetch Workspaces (if multi-workspace support is needed)

Client Call:

js
Copy
Edit
const { data: workspaces, error } = await supabase
  .from("workspaces")
  .select("id, name")
  .eq("created_by", supabase.auth.user().id);
Response:

jsonc
Copy
Edit
[
  {
    "id": "workspace-uuid-456",
    "name": "ACME Corp"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

3. Channel Endpoints
List Channels

Client Call:

js
Copy
Edit
const { data: channels, error } = await supabase
  .from("channels")
  .select("id, name, description, created_by, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .order("name", { ascending: true });
Response:

jsonc
Copy
Edit
[
  {
    "id": "c1a2b3d4-...",
    "name": "general",
    "description": "Company-wide announcements",
    "created_by": "user-uuid-123",
    "created_at": "2025-06-01T10:15:34.123Z"
  },
  {
    "id": "d2e3f4g5-...",
    "name": "project-alpha",
    "description": "Discussion for Project Alpha",
    "created_by": "user-uuid-456",
    "created_at": "2025-06-01T11:20:00.456Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Create Channel

Client Call:

js
Copy
Edit
const { data: newChannel, error } = await supabase
  .from("channels")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      name: "project-beta",
      description: "Beta project discussions",
      created_by: "<users.id>"
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "name": "project-beta",
  "description": "Beta project discussions",
  "created_by": "<users.id>"
}
Response:

jsonc
Copy
Edit
{
  "id": "e3f4g5h6-...",
  "workspace_id": "<workspace_uuid>",
  "name": "project-beta",
  "description": "Beta project discussions",
  "created_by": "<users.id>",
  "created_at": "2025-06-02T09:00:00.000Z"
}
Common Errors:

400 Bad Request: Missing name or workspace has already 10 channels.

409 Conflict: Name collision in same workspace.

403 Forbidden: Unauthorized (RLS).

4. Message Endpoints
List Messages in a Channel

Client Call:

js
Copy
Edit
const { data: messages, error } = await supabase
  .from("messages")
  .select("id, user_id, content, parent_message_id, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .eq("channel_id", "<channel_uuid>")
  .order("created_at", { ascending: true })
  .limit(50);
Response:

jsonc
Copy
Edit
[
  {
    "id": "m1a2b3d4-...",
    "user_id": "user-uuid-123",
    "content": "Hey team, good morning!",
    "parent_message_id": null,
    "created_at": "2025-06-02T09:15:00.000Z"
  },
  {
    "id": "m2b3c4d5-...",
    "user_id": "user-uuid-456",
    "content": "Good morning, @alice!",
    "parent_message_id": "m1a2b3d4-...",
    "created_at": "2025-06-02T09:16:00.000Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Post a Message

Client Call:

js
Copy
Edit
const { data: newMessage, error } = await supabase
  .from("messages")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      channel_id: "<channel_uuid>",
      user_id: "<users.id>",
      content: "Here’s the project update...",
      parent_message_id: null
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Here’s the project update...",
  "parent_message_id": null
}
Response:

jsonc
Copy
Edit
{
  "id": "n3o4p5q6-...",
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Here’s the project update...",
  "parent_message_id": null,
  "created_at": "2025-06-02T09:30:00.000Z"
}
Common Errors:

400 Bad Request: Missing required fields.

403 Forbidden: Unauthorized (RLS).

List Thread (Replies)

Client Call:

js
Copy
Edit
const { data: threadReplies, error } = await supabase
  .from("messages")
  .select("id, user_id, content, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .eq("parent_message_id", "<parent_message_uuid>")
  .order("created_at", { ascending: true });
Response:

jsonc
Copy
Edit
[
  {
    "id": "t1u2v3w4-...",
    "user_id": "user-uuid-789",
    "content": "Thanks for the update!",
    "created_at": "2025-06-02T09:31:00.000Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Post a Thread Reply

Client Call:

js
Copy
Edit
const { data: reply, error } = await supabase
  .from("messages")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      channel_id: "<channel_uuid>",
      user_id: "<users.id>",
      content: "Adding my thoughts...",
      parent_message_id: "<parent_message_uuid>"
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Adding my thoughts...",
  "parent_message_id": "<parent_message_uuid>"
}
Response:

jsonc
Copy
Edit
{
  "id": "t4v5w6x7-...",
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Adding my thoughts...",
  "parent_message_id": "<parent_message_uuid>",
  "created_at": "2025-06-02T09:32:00.000Z"
}
Common Errors:

400 Bad Request: Missing required fields.

403 Forbidden: Unauthorized (RLS).

5. File Attachments Endpoints
Upload Attachment (PDF/TXT)

Client Side (JS SDK):

js
Copy
Edit
const file = /* File object from <input type="file"> */;
const fileExt = file.name.split('.').pop();
const fileName = `${uuidv4()}.${fileExt}`;
const filePath = `workspaces/${workspaceId}/channel_${channelId}/${fileName}`;

// 1) Upload to Supabase Storage
const { data: uploadData, error: uploadError } = await supabaseClient
  .storage
  .from("attachments-bucket")
  .upload(filePath, file, {
    cacheControl: "3600",
    upsert: false
  });

if (uploadError) {
  // Handle error (e.g., size/type validation)
} else {
  // 2) Insert metadata row in `attachments` table
  const { data: attachment, error } = await supabase
    .from("attachments")
    .insert([
      {
        workspace_id: "<workspace_uuid>",
        channel_id: "<channel_uuid>",
        message_id: "<message_uuid>",
        storage_path: uploadData.Key,
        filename: file.name,
        uploaded_by: "<users.id>"
      }
    ])
    .single();

  // 3) Generate a signed URL to show/download
  const { signedURL, error: urlError } = await supabaseClient
    .storage
    .from("attachments-bucket")
    .createSignedUrl(uploadData.Key, 60); // valid for 60s
  // Use `signedURL` in the UI.
}
SQL Constraint (already defined):

sql
Copy
Edit
ALTER TABLE public.attachments
  ADD CONSTRAINT chk_attachment_filetype
    CHECK ( filename ILIKE '%.pdf' OR filename ILIKE '%.txt' );
Common Errors:

Attempt to upload unsupported file type or >10 MB (client-side validation should catch).

403 Forbidden if RLS denies (uploading to wrong workspace).

Get Signed URL for Attachment

Client Call:

js
Copy
Edit
const { signedURL, error } = await supabaseClient
  .storage
  .from("attachments-bucket")
  .createSignedUrl("<storage_path>", 60);
Response:

jsonc
Copy
Edit
{
  "signedURL": "https://xyz.supabase.co/storage/v1/object/..."
}
Common Errors:

403 Forbidden: Trying to fetch a file outside the user’s workspace path.

6. Unread Count Endpoints
We implement an RPC function get_unread_count to count messages after a user’s last read time.

RPC Function: get_unread_count (create in Supabase SQL Editor)

sql
Copy
Edit
CREATE FUNCTION public.get_unread_count(
  p_user_id UUID,
  p_channel_id UUID
) RETURNS TABLE (unread_count BIGINT) AS $$
BEGIN
  RETURN QUERY
  SELECT COUNT(*)::BIGINT
  FROM public.messages m
  JOIN public.user_channel_reads ucr
    ON ucr.user_id = p_user_id
    AND ucr.channel_id = p_channel_id
    AND ucr.workspace_id = m.workspace_id
  WHERE m.channel_id = p_channel_id
    AND m.created_at > ucr.last_read_at;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
RLS: Because this is a SECURITY DEFINER function, it bypasses RLS when executed. Use it carefully, ensuring that the arguments p_user_id and p_channel_id have already been verified on the client side (or wrap in an Edge Function to verify).

Get Unread Count (Client)

js
Copy
Edit
const { data: countResult, error } = await supabase.rpc("get_unread_count", {
  p_user_id: "<users.id>",
  p_channel_id: "<channel_uuid>"
});
Response:

jsonc
Copy
Edit
{
  "unread_count": 5
}
Common Errors:

403 Forbidden: If either user_id or channel_id does not belong to the same workspace (enforce on client).

Mark Channel as Read (Client)

js
Copy
Edit
const { data, error } = await supabase
  .from("user_channel_reads")
  .upsert({
    workspace_id: "<workspace_uuid>",
    user_id: "<users.id>",
    channel_id: "<channel_uuid>",
    last_read_at: new Date().toISOString()
  }, { onConflict: ["user_id", "channel_id"] });
Response:

jsonc
Copy
Edit
{
  "id": "r1s2t3u4-...", 
  "workspace_id": "<workspace_uuid>",
  "user_id": "<users.id>",
  "channel_id": "<channel_uuid>",
  "last_read_at": "2025-06-02T10:00:00.000Z"
}
Common Errors:

403 Forbidden: If the user or channel is not in that workspace (RLS).

Security Measures
Row-Level Security (RLS) Policies

Each table has RLS enabled. Policies ensure users can only operate on rows where workspace_id matches their assigned workspace, and (where relevant) user_id matches their own user ID.

Example snippet for the messages table:

sql
Copy
Edit
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- SELECT: Only messages in the user’s workspace
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- INSERT: Only if workspace_id = user’s workspace AND user_id = user’s id
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- UPDATE/DELETE: Only the message owner in their workspace
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Similar RLS policies are defined for workspaces, users, channels, attachments, and user_channel_reads.

Supabase Storage Security

Create a private bucket named attachments-bucket.

Files are written under the path pattern:

bash
Copy
Edit
workspaces/{workspace_id}/channel_{channel_id}/{uuid4}_{filename}
No public access—clients must request signed URLs to download/view.

Input Validation & Sanitization

Database Constraints

Non-null constraints on required columns (e.g., content in messages).

CHECK constraint on filename to allow only .pdf or .txt.

Client-Side Validation

Verify file type/size before uploading.

Escape or sanitize user-provided text to prevent injection (although rendering as plain text in React typically suffices).

HTTPS & CORS

All Supabase endpoints are HTTPS by default.

In Supabase Dashboard → Settings → API → Allowed origins, add your frontend’s URL (e.g., https://your-app.vercel.app) and http://localhost:3000 (for development).

Rate Limiting & Throttling

For MVP scale (≤50 concurrent users), default Supabase limits should suffice.

On client side, throttle message submissions (e.g., no more than 5 messages/second).

If using custom Edge Functions for AI features later, implement per-workspace or per-user rate limits as needed (e.g., Redis counter).

API Design & Documentation (Summary)
Below is a concise mapping of front-end actions to Supabase calls or RPC:

Action	Supabase Call / RPC	Notes
Sign Up	supabase.auth.signUp({ email, password })
—plus DB trigger to create workspaces and users	Edge Function or Postgres trigger handles post-sign-up inserts.
Sign In	supabase.auth.signIn({ email, password })	Returns session & user; then fetch users row.
Fetch User Profile	supabase.from("users").select(...).eq("auth_id", auth.uid()).single()	Retrieves workspace_id and profile metadata.
List Channels	supabase.from("channels").select(...).eq("workspace_id", …)	Ordered by name.
Create Channel	supabase.from("channels").insert([{ … }]).single()	Must enforce max 10 channels per workspace on client.
List Messages (last 50)	supabase.from("messages").select(...).eq("workspace_id", …).eq("channel_id", …).order("created_at", { ascending: true }).limit(50)	Includes parent_message_id.
Post a Message	supabase.from("messages").insert([{ … }]).single()	Payload: workspace_id, channel_id, user_id, content, parent_message_id (nullable).
List Thread Replies	supabase.from("messages").select(...).eq("workspace_id", …).eq("parent_message_id", …).order("created_at", { ascending: true })	Fetches replies to a given parent message.
Post Thread Reply	supabase.from("messages").insert([{ … }]).single()	Same fields, but parent_message_id ≠ null.
Upload Attachment	1) supabase.storage.from("attachments-bucket").upload(path, file) 2) supabase.from("attachments").insert([{ … }]).single()	Path convention: workspaces/{workspace_id}/channel_{channel_id}/{uuid}_{filename}.
Get Signed URL	supabase.storage.from("attachments-bucket").createSignedUrl(path, 60)	Returns URL valid for 60 seconds.
Get Unread Count	RPC supabase.rpc("get_unread_count", { p_user_id, p_channel_id })	Defined in SQL above; returns { unread_count }.
Mark Channel Read	supabase.from("user_channel_reads").upsert({ … }, { onConflict: ["user_id","channel_id"] })	Inserts or updates last_read_at.

Third-Party Integration Guidelines
At MVP stage, no third-party AI integrations are implemented. Below guidelines apply when adding AI features (Phase 2).

LLM Provider (e.g., OpenAI, Anthropic)

Never expose API keys to the client. All calls must go through a secure Edge Function or serverless proxy that:

Verifies workspace_id belongs to the authenticated auth.uid().

Queries any vector store or document store (filtered by workspace_id) to build context.

Sends the combined prompt/context to the LLM, using the SERVICE_ROLE_KEY to retrieve protected data if needed.

Returns a structured JSON to the frontend (e.g., { summary: "...", sources: [ { channel: "...", timestamp: "..." } ] }).

Vector Store (for embeddings / RAG)

Option A: Enable and use Supabase’s pgvector extension (if on a tier that supports it).

Option B: Spin up a dedicated vector-DB (Pinecone, Weaviate).

Requirement: All embeddings or documents must include workspace_id metadata. During retrieval, always filter by workspace_id to prevent cross-workspace leakage.

OCR / Text Extraction (for PDF attachments)

Implement a serverless function triggered on a new file upload to:

Download the PDF from Supabase Storage.

Run OCR or text extraction (e.g., Tesseract.js or a small Python Lambda).

Insert extracted text into a documents table (fields: id, workspace_id, channel_id, message_id, text, created_at).

Use that text as part of the RAG index.

Monitoring & Logging

When adding AI endpoints, log each request with workspace_id, endpoint, request_time, and response_time.

Integrate Sentry (or your preferred APM) for error tracking in Edge Functions.

Security Measures (Summary)
RLS Policies

Enforce workspace_id matching for every table.

For tables referencing user_id, also ensure user_id = SELECT id FROM users WHERE auth_id = auth.uid().

Storage Bucket ACL

Bucket is private.

Files are accessible only via signed URLs, which expire.

Constraints & Validation

All NOT NULL columns enforced in DDL.

Filetype constraint on attachments.filename.

Unique constraints (e.g., (workspace_id, name) on channels).

HTTPS & CORS

Supabase endpoints require HTTPS.

Configure CORS to allow only your frontend origin(s).

Rate Limiting / Throttling

MVP scale: rely on default Supabase limits.

In future, add per-workspace or per-user rate limits in Edge Functions for AI calls.

Appendix: Complete RLS Policy Snippets
sql
Copy
Edit
-- workspaces table RLS
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;
CREATE POLICY insert_workspace ON public.workspaces
  FOR INSERT
  WITH CHECK ( auth.uid() = created_by );
CREATE POLICY select_workspace ON public.workspaces
  FOR SELECT
  USING ( auth.uid() = created_by );

-- users table RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_self_user ON public.users
  FOR SELECT
  USING ( auth.uid() = auth_id );
CREATE POLICY insert_user ON public.users
  FOR INSERT
  WITH CHECK ( auth.uid() = auth_id );
CREATE POLICY update_self_user ON public.users
  FOR UPDATE
  USING ( auth.uid() = auth_id )
  WITH CHECK ( auth.uid() = auth_id );

-- channels table RLS
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_channels ON public.channels
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_channels ON public.channels
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY update_channels ON public.channels
  FOR UPDATE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  )
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_channels ON public.channels
  FOR DELETE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- messages table RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- attachments table RLS
ALTER TABLE public.attachments ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_attachments ON public.attachments
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_attachments ON public.attachments
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND uploaded_by = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_attachments ON public.attachments
  FOR DELETE
  USING (
    uploaded_by = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- user_channel_reads table RLS
ALTER TABLE public.user_channel_reads ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_reads ON public.user_channel_reads
  FOR SELECT
  USING (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY upsert_reads ON public.user_channel_reads
  FOR INSERT, UPDATE
  WITH CHECK (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_reads ON public.user_channel_reads
  FOR DELETE
  USING (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )

  );