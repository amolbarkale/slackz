---
description: 
globs: 
alwaysApply: true
---
Supabase Setup & Configuration
Create Supabase Project

Sign in to Supabase and create a new project (select a region closest to your user base).

Enable the following services:

Auth

Database (Postgres)

Storage

Realtime

Retrieve API Keys & URLs

In the Supabase dashboard, note down:

SUPABASE_URL

SUPABASE_ANON_KEY

SERVICE_ROLE_KEY (for any server-side logic)

Enable Extensions

Using Supabase SQL Editor, run:

sql
Copy
Edit
-- Enable pgcrypto for UUID generation
CREATE EXTENSION IF NOT EXISTS "pgcrypto";
(Future / Phase 2): Reserve pgvector for AI features, but do not enable it for MVP.

Configure Environment Variables

In your frontend (React) environment (e.g., .env.local):

ini
Copy
Edit
NEXT_PUBLIC_SUPABASE_URL=your_supabase_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key
In any serverless/Edge Function environment:

ini
Copy
Edit
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key
Enable Row-Level Security (RLS)

For every table created below, immediately enable RLS and define policies.

This ensures strict, row-level data isolation by workspace_id (and user_id where applicable).

Authentication & Authorization
Supabase Auth (Email/Password)
Sign-Up Flow (Client)

Frontend calls:

js
Copy
Edit
await supabase.auth.signUp({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Post-Sign-Up Trigger (Edge Function or Postgres Trigger) automatically:

Inserts a new row into workspaces (using a provided workspace_name).

Inserts a new row into users linking auth.users.id → users.auth_id, assigning workspace_id.

Sign-In Flow (Client)

js
Copy
Edit
const { user, session, error } = await supabase.auth.signIn({
  email: "alice@example.com",
  password: "StrongPassword123"
});
On success, fetch the corresponding users row to retrieve workspace_id and other profile details.

Fetch User Profile (Client)

js
Copy
Edit
const { data: profile, error } = await supabase
  .from("users")
  .select("id, full_name, email, workspace_id, avatar_url")
  .eq("auth_id", supabase.auth.user().id)
  .single();
Returns the users table row for the signed-in user.

Authorization (“Single Role: user”)
All authenticated users share the same “user” role.

Authorization is enforced via RLS policies on every table, ensuring that users can only read/write rows where workspace_id matches their own and (where relevant) user_id = their own user ID.

Database Schema Design
Naming conventions

Tables and columns: lowercase with underscores.

UUID primary keys generated by gen_random_uuid().

Timestamps: created_at TIMESTAMPTZ DEFAULT now().

Each table includes workspace_id for scoping.

Below are all tables, with columns, constraints, indexes, and RLS policies.

1. Table: workspaces
sql
Copy
Edit
CREATE TABLE public.workspaces (
  id          UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  name        TEXT         NOT NULL UNIQUE,
  created_by  UUID         NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  created_at  TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;

-- Policy: Allow a user to insert a workspace only if they are the creator
CREATE POLICY insert_workspace ON public.workspaces
  FOR INSERT
  WITH CHECK ( auth.uid() = created_by );

-- Policy: Allow a user to select their own workspace
CREATE POLICY select_workspace ON public.workspaces
  FOR SELECT
  USING ( auth.uid() = created_by );
Columns

id (UUID, PK)

name (TEXT, unique)

created_by (UUID → auth.users.id)

created_at (TIMESTAMPTZ)

RLS

Only the user whose auth_id matches created_by can insert or select.

2. Table: users
sql
Copy
Edit
CREATE TABLE public.users (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_id       UUID         NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name     TEXT         NOT NULL,
  email         TEXT         NOT NULL,
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  avatar_url    TEXT,
  created_at    TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- Policy: Allow a user to select only their own profile
CREATE POLICY select_self_user ON public.users
  FOR SELECT
  USING ( auth.uid() = auth_id );

-- Policy: Allow a user to insert only if they are creating their own record
CREATE POLICY insert_user ON public.users
  FOR INSERT
  WITH CHECK ( auth.uid() = auth_id );

-- Policy: Allow a user to update only their own profile
CREATE POLICY update_self_user ON public.users
  FOR UPDATE
  USING ( auth.uid() = auth_id )
  WITH CHECK ( auth.uid() = auth_id );
Columns

id (UUID, PK)

auth_id (UUID → auth.users.id, unique)

full_name (TEXT)

email (TEXT)

workspace_id (UUID → workspaces.id)

avatar_url (TEXT, nullable)

created_at (TIMESTAMPTZ)

RLS

Users can only read/insert/update their own row (via auth_id).

3. Table: channels
sql
Copy
Edit
CREATE TABLE public.channels (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  name          TEXT         NOT NULL,
  description   TEXT,
  created_by    UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  created_at    TIMESTAMPTZ  NOT NULL DEFAULT now(),
  UNIQUE (workspace_id, name)
);

-- Enable RLS
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select channels only in their workspace
CREATE POLICY select_channels ON public.channels
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert a channel only if it belongs to their workspace
CREATE POLICY insert_channels ON public.channels
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to update channels only in their workspace
CREATE POLICY update_channels ON public.channels
  FOR UPDATE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  )
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete channels only in their workspace
CREATE POLICY delete_channels ON public.channels
  FOR DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

name (TEXT, unique per workspace)

description (TEXT, nullable)

created_by (UUID → users.id)

created_at (TIMESTAMPTZ)

Indexes

Unique index on (workspace_id, name).

RLS

All selects/inserts/updates/deletes restricted to the user's own workspace.

4. Table: messages
sql
Copy
Edit
CREATE TABLE public.messages (
  id                UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id      UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  channel_id        UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  parent_message_id UUID         REFERENCES public.messages(id) ON DELETE CASCADE,
  user_id           UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  content           TEXT         NOT NULL,
  created_at        TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Indexes for fast lookups
CREATE INDEX idx_messages_channel_created_at
  ON public.messages (channel_id, created_at ASC);

CREATE INDEX idx_threads_parent_created_at
  ON public.messages (parent_message_id, created_at ASC);

-- Enable RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select messages only in their workspace
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert messages only if they belong to their workspace and user_id matches
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to update or delete only their own messages in their workspace
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

channel_id (UUID → channels.id)

parent_message_id (UUID → messages.id, nullable)

user_id (UUID → users.id)

content (TEXT)

created_at (TIMESTAMPTZ)

Indexes

(channel_id, created_at) for channel-ordered fetches.

(parent_message_id, created_at) for thread lookups.

RLS

All operations scoped to user's workspace; only the message owner can update/delete.

5. Table: attachments
sql
Copy
Edit
CREATE TABLE public.attachments (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  channel_id    UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  message_id    UUID         NOT NULL REFERENCES public.messages(id) ON DELETE CASCADE,
  storage_path  TEXT         NOT NULL,
  filename      TEXT         NOT NULL,
  uploaded_by   UUID         NOT NULL REFERENCES public.users(id) ON DELETE SET NULL,
  uploaded_at   TIMESTAMPTZ  NOT NULL DEFAULT now()
);

-- Index for fast message-attachment lookups
CREATE INDEX idx_attachments_message
  ON public.attachments (message_id);

-- Enforce filetype (PDF or TXT) at DB level
ALTER TABLE public.attachments
  ADD CONSTRAINT chk_attachment_filetype
    CHECK ( filename ILIKE '%.pdf' OR filename ILIKE '%.txt' );

-- Enable RLS
ALTER TABLE public.attachments ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select attachments only in their workspace
CREATE POLICY select_attachments ON public.attachments
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to insert attachments only if workspace_id matches and uploader is themselves
CREATE POLICY insert_attachments ON public.attachments
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND uploaded_by = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete attachments only if they uploaded them and it's their workspace
CREATE POLICY delete_attachments ON public.attachments
  FOR DELETE
  USING (
    uploaded_by = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

channel_id (UUID → channels.id)

message_id (UUID → messages.id)

storage_path (TEXT)

filename (TEXT, must end in .pdf or .txt)

uploaded_by (UUID → users.id)

uploaded_at (TIMESTAMPTZ)

Index

On message_id for quick lookups.

RLS

Only workspace members can insert/select; only uploader can delete.

6. Table: user_channel_reads
sql
Copy
Edit
CREATE TABLE public.user_channel_reads (
  id            UUID         PRIMARY KEY DEFAULT gen_random_uuid(),
  workspace_id  UUID         NOT NULL REFERENCES public.workspaces(id) ON DELETE CASCADE,
  user_id       UUID         NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,
  channel_id    UUID         NOT NULL REFERENCES public.channels(id) ON DELETE CASCADE,
  last_read_at  TIMESTAMPTZ  NOT NULL DEFAULT now(),
  UNIQUE (user_id, channel_id)
);

-- Enable RLS
ALTER TABLE public.user_channel_reads ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to select their own read status only in their workspace
CREATE POLICY select_reads ON public.user_channel_reads
  FOR SELECT
  USING (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to upsert (insert/update) their own read status only in their workspace
CREATE POLICY upsert_reads ON public.user_channel_reads
  FOR INSERT, UPDATE
  WITH CHECK (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- Policy: Allow users to delete their own read status only in their workspace
CREATE POLICY delete_reads ON public.user_channel_reads
  FOR DELETE
  USING (
    user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Columns

id (UUID, PK)

workspace_id (UUID → workspaces.id)

user_id (UUID → users.id)

channel_id (UUID → channels.id)

last_read_at (TIMESTAMPTZ)

Constraints

Unique composite key (user_id, channel_id).

RLS

Only workspace members can insert/select/update/delete their own rows.

API Endpoints & Documentation
Most "endpoints" in a Supabase-powered backend are handled via the Supabase Client (REST or JS SDK). Below is a logical mapping of front-end actions to Supabase calls, with clear request/response shapes.

Important: All client requests must include a valid Supabase session/token. RLS policies will enforce authorization.

1. Authentication Endpoints
Sign Up

Client Call (JS SDK):

js
Copy
Edit
const { user, session, error } = await supabase.auth.signUp({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Side Effects (via DB Trigger or Edge Function):

Create a new workspaces row using provided workspace_name.

Create a new users row with:

auth_id = auth.user().id

email = auth.user().email

full_name = provided full_name

workspace_id = newly created workspace.id

Response (Client):

jsonc
Copy
Edit
{
  "user": { /* auth.user() object */ },
  "session": { /* Supabase session object */ },
  "error": null
}
Common Errors:

400 Bad Request: Missing or invalid email/password.

409 Conflict: Workspace name already exists.

Sign In

Client Call:

js
Copy
Edit
const { user, session, error } = await supabase.auth.signIn({
  email: "alice@example.com",
  password: "StrongPassword123"
});
Response:

jsonc
Copy
Edit
{
  "user": { /* auth.user() object */ },
  "session": { /* Supabase session object */ },
  "error": null
}
Common Errors:

400 Bad Request: Missing credentials.

401 Unauthorized: Incorrect email/password.

Fetch User Profile

Client Call:

js
Copy
Edit
const { data: profile, error } = await supabase
  .from("users")
  .select("id, full_name, email, workspace_id, avatar_url")
  .eq("auth_id", supabase.auth.user().id)
  .single();
Response:

jsonc
Copy
Edit
{
  "id": "user-uuid-123",
  "full_name": "Alice Johnson",
  "email": "alice@example.com",
  "workspace_id": "workspace-uuid-456",
  "avatar_url": null
}
Common Errors:

404 Not Found: No user row found (should not happen if triggers are correct).

2. Workspace Endpoints
Fetch Workspaces (if multi-workspace support is needed)

Client Call:

js
Copy
Edit
const { data: workspaces, error } = await supabase
  .from("workspaces")
  .select("id, name")
  .eq("created_by", supabase.auth.user().id);
Response:

jsonc
Copy
Edit
[
  {
    "id": "workspace-uuid-456",
    "name": "ACME Corp"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

3. Channel Endpoints
List Channels

Client Call:

js
Copy
Edit
const { data: channels, error } = await supabase
  .from("channels")
  .select("id, name, description, created_by, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .order("name", { ascending: true });
Response:

jsonc
Copy
Edit
[
  {
    "id": "c1a2b3d4-...",
    "name": "general",
    "description": "Company-wide announcements",
    "created_by": "user-uuid-123",
    "created_at": "2025-06-01T10:15:34.123Z"
  },
  {
    "id": "d2e3f4g5-...",
    "name": "project-alpha",
    "description": "Discussion for Project Alpha",
    "created_by": "user-uuid-456",
    "created_at": "2025-06-01T11:20:00.456Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Create Channel

Client Call:

js
Copy
Edit
const { data: newChannel, error } = await supabase
  .from("channels")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      name: "project-beta",
      description: "Beta project discussions",
      created_by: "<users.id>"
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "name": "project-beta",
  "description": "Beta project discussions",
  "created_by": "<users.id>"
}
Response:

jsonc
Copy
Edit
{
  "id": "e3f4g5h6-...",
  "workspace_id": "<workspace_uuid>",
  "name": "project-beta",
  "description": "Beta project discussions",
  "created_by": "<users.id>",
  "created_at": "2025-06-02T09:00:00.000Z"
}
Common Errors:

400 Bad Request: Missing name or workspace has already 10 channels.

409 Conflict: Name collision in same workspace.

403 Forbidden: Unauthorized (RLS).

4. Message Endpoints
List Messages in a Channel

Client Call:

js
Copy
Edit
const { data: messages, error } = await supabase
  .from("messages")
  .select("id, user_id, content, parent_message_id, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .eq("channel_id", "<channel_uuid>")
  .order("created_at", { ascending: true })
  .limit(50);
Response:

jsonc
Copy
Edit
[
  {
    "id": "m1a2b3d4-...",
    "user_id": "user-uuid-123",
    "content": "Hey team, good morning!",
    "parent_message_id": null,
    "created_at": "2025-06-02T09:15:00.000Z"
  },
  {
    "id": "m2b3c4d5-...",
    "user_id": "user-uuid-456",
    "content": "Good morning, @alice!",
    "parent_message_id": "m1a2b3d4-...",
    "created_at": "2025-06-02T09:16:00.000Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Post a Message

Client Call:

js
Copy
Edit
const { data: newMessage, error } = await supabase
  .from("messages")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      channel_id: "<channel_uuid>",
      user_id: "<users.id>",
      content: "Here's the project update...",
      parent_message_id: null
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Here's the project update...",
  "parent_message_id": null
}
Response:

jsonc
Copy
Edit
{
  "id": "n3o4p5q6-...",
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Here's the project update...",
  "parent_message_id": null,
  "created_at": "2025-06-02T09:30:00.000Z"
}
Common Errors:

400 Bad Request: Missing required fields.

403 Forbidden: Unauthorized (RLS).

List Thread (Replies)

Client Call:

js
Copy
Edit
const { data: threadReplies, error } = await supabase
  .from("messages")
  .select("id, user_id, content, created_at")
  .eq("workspace_id", "<workspace_uuid>")
  .eq("parent_message_id", "<parent_message_uuid>")
  .order("created_at", { ascending: true });
Response:

jsonc
Copy
Edit
[
  {
    "id": "t1u2v3w4-...",
    "user_id": "user-uuid-789",
    "content": "Thanks for the update!",
    "created_at": "2025-06-02T09:31:00.000Z"
  }
]
Common Errors:

403 Forbidden: Unauthorized (RLS).

Post a Thread Reply

Client Call:

js
Copy
Edit
const { data: reply, error } = await supabase
  .from("messages")
  .insert([
    {
      workspace_id: "<workspace_uuid>",
      channel_id: "<channel_uuid>",
      user_id: "<users.id>",
      content: "Adding my thoughts...",
      parent_message_id: "<parent_message_uuid>"
    }
  ])
  .single();
Request Body:

jsonc
Copy
Edit
{
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Adding my thoughts...",
  "parent_message_id": "<parent_message_uuid>"
}
Response:

jsonc
Copy
Edit
{
  "id": "t4v5w6x7-...",
  "workspace_id": "<workspace_uuid>",
  "channel_id": "<channel_uuid>",
  "user_id": "<users.id>",
  "content": "Adding my thoughts...",
  "parent_message_id": "<parent_message_uuid>",
  "created_at": "2025-06-02T09:32:00.000Z"
}
Common Errors:

400 Bad Request: Missing required fields.

403 Forbidden: Unauthorized (RLS).

5. File Attachments Endpoints
Upload Attachment (PDF/TXT)

Client Side (JS SDK):

js
Copy
Edit
const file = /* File object from <input type="file"> */;
const fileExt = file.name.split('.').pop();
const fileName = `${uuidv4()}.${fileExt}`;
const filePath = `workspaces/${workspaceId}/channel_${channelId}/${fileName}`;

// 1) Upload to Supabase Storage
const { data: uploadData, error: uploadError } = await supabaseClient
  .storage
  .from("attachments-bucket")
  .upload(filePath, file, {
    cacheControl: "3600",
    upsert: false
  });

if (uploadError) {
  // Handle error (e.g., size/type validation)
} else {
  // 2) Insert metadata row in `attachments` table
  const { data: attachment, error } = await supabase
    .from("attachments")
    .insert([
      {
        workspace_id: "<workspace_uuid>",
        channel_id: "<channel_uuid>",
        message_id: "<message_uuid>",
        storage_path: uploadData.Key,
        filename: file.name,
        uploaded_by: "<users.id>"
      }
    ])
    .single();

  // 3) Generate a signed URL to show/download
  const { signedURL, error: urlError } = await supabaseClient
    .storage
    .from("attachments-bucket")
    .createSignedUrl(uploadData.Key, 60); // valid for 60s
  // Use `signedURL` in the UI.
}
SQL Constraint (already defined):

sql
Copy
Edit
ALTER TABLE public.attachments
  ADD CONSTRAINT chk_attachment_filetype
    CHECK ( filename ILIKE '%.pdf' OR filename ILIKE '%.txt' );
Common Errors:

Attempt to upload unsupported file type or >10 MB (client-side validation should catch).

403 Forbidden if RLS denies (uploading to wrong workspace).

Get Signed URL for Attachment

Client Call:

js
Copy
Edit
const { signedURL, error } = await supabaseClient
  .storage
  .from("attachments-bucket")
  .createSignedUrl("<storage_path>", 60);
Response:

jsonc
Copy
Edit
{
  "signedURL": "https://xyz.supabase.co/storage/v1/object/..."
}
Common Errors:

403 Forbidden: Trying to fetch a file outside the user's workspace path.

6. Unread Count Endpoints
We implement an RPC function get_unread_count to count messages after a user's last read time.

RPC Function: get_unread_count (create in Supabase SQL Editor)

sql
Copy
Edit
CREATE FUNCTION public.get_unread_count(
  p_user_id UUID,
  p_channel_id UUID
) RETURNS TABLE (unread_count BIGINT) AS $$
BEGIN
  RETURN QUERY
  SELECT COUNT(*)::BIGINT
  FROM public.messages m
  JOIN public.user_channel_reads ucr
    ON ucr.user_id = p_user_id
    AND ucr.channel_id = p_channel_id
    AND ucr.workspace_id = m.workspace_id
  WHERE m.channel_id = p_channel_id
    AND m.created_at > ucr.last_read_at;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
RLS: Because this is a SECURITY DEFINER function, it bypasses RLS when executed. Use it carefully, ensuring that the arguments p_user_id and p_channel_id have already been verified on the client side (or wrap in an Edge Function to verify).

Get Unread Count (Client)

js
Copy
Edit
const { data: countResult, error } = await supabase.rpc("get_unread_count", {
  p_user_id: "<users.id>",
  p_channel_id: "<channel_uuid>"
});
Response:

jsonc
Copy
Edit
{
  "unread_count": 5
}
Common Errors:

403 Forbidden: If either user_id or channel_id does not belong to the same workspace (enforce on client).

Mark Channel as Read (Client)

js
Copy
Edit
const { data, error } = await supabase
  .from("user_channel_reads")
  .upsert({
    workspace_id: "<workspace_uuid>",
    user_id: "<users.id>",
    channel_id: "<channel_uuid>",
    last_read_at: new Date().toISOString()
  }, { onConflict: ["user_id", "channel_id"] });
Response:

jsonc
Copy
Edit
{
  "id": "r1s2t3u4-...", 
  "workspace_id": "<workspace_uuid>",
  "user_id": "<users.id>",
  "channel_id": "<channel_uuid>",
  "last_read_at": "2025-06-02T10:00:00.000Z"
}
Common Errors:

403 Forbidden: If the user or channel is not in that workspace (RLS).

Security Measures
Row-Level Security (RLS) Policies

Each table has RLS enabled. Policies ensure users can only operate on rows where workspace_id matches their assigned workspace, and (where relevant) user_id matches their own user ID.

Example snippet for the messages table:

sql
Copy
Edit
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

-- SELECT: Only messages in the user's workspace
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- INSERT: Only if workspace_id = user's workspace AND user_id = user's id
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );

-- UPDATE/DELETE: Only the message owner in their workspace
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id
      FROM public.users
      WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id
      FROM public.users
      WHERE auth_id = auth.uid()
    )
  );
Similar RLS policies are defined for workspaces, users, channels, attachments, and user_channel_reads.

Supabase Storage Security

Create a private bucket named attachments-bucket.

Files are written under the path pattern:

bash
Copy
Edit
workspaces/{workspace_id}/channel_{channel_id}/{uuid4}_{filename}
No public access—clients must request signed URLs to download/view.

Input Validation & Sanitization

Database Constraints

Non-null constraints on required columns (e.g., content in messages).

CHECK constraint on filename to allow only .pdf or .txt.

Client-Side Validation

Verify file type/size before uploading.

Escape or sanitize user-provided text to prevent injection (although rendering as plain text in React typically suffices).

HTTPS & CORS

All Supabase endpoints are HTTPS by default.

In Supabase Dashboard → Settings → API → Allowed origins, add your frontend's URL (e.g., https://your-app.vercel.app) and http://localhost:3000 (for development).

Rate Limiting & Throttling

For MVP scale (≤50 concurrent users), default Supabase limits should suffice.

On client side, throttle message submissions (e.g., no more than 5 messages/second).

If using custom Edge Functions for AI features later, implement per-workspace or per-user rate limits as needed (e.g., Redis counter).

API Design & Documentation (Summary)
Below is a concise mapping of front-end actions to Supabase calls or RPC:

Action	Supabase Call / RPC	Notes
Sign Up	supabase.auth.signUp({ email, password })
—plus DB trigger to create workspaces and users	Edge Function or Postgres trigger handles post-sign-up inserts.
Sign In	supabase.auth.signIn({ email, password })	Returns session & user; then fetch users row.
Fetch User Profile	supabase.from("users").select(...).eq("auth_id", auth.uid()).single()	Retrieves workspace_id and profile metadata.
List Channels	supabase.from("channels").select(...).eq("workspace_id", …)	Ordered by name.
Create Channel	supabase.from("channels").insert([{ … }]).single()	Must enforce max 10 channels per workspace on client.
List Messages (last 50)	supabase.from("messages").select(...).eq("workspace_id", …).eq("channel_id", …).order("created_at", { ascending: true }).limit(50)	Includes parent_message_id.
Post a Message	supabase.from("messages").insert([{ … }]).single()	Payload: workspace_id, channel_id, user_id, content, parent_message_id (nullable).
List Thread Replies	supabase.from("messages").select(...).eq("workspace_id", …).eq("parent_message_id", …).order("created_at", { ascending: true })	Fetches replies to a given parent message.
Post Thread Reply	supabase.from("messages").insert([{ … }]).single()	Same fields, but parent_message_id ≠ null.
Upload Attachment	1) supabase.storage.from("attachments-bucket").upload(path, file) 2) supabase.from("attachments").insert([{ … }]).single()	Path convention: workspaces/{workspace_id}/channel_{channel_id}/{uuid}_{filename}.
Get Signed URL	supabase.storage.from("attachments-bucket").createSignedUrl(path, 60)	Returns URL valid for 60 seconds.
Get Unread Count	RPC supabase.rpc("get_unread_count", { p_user_id, p_channel_id })	Defined in SQL above; returns { unread_count }.
Mark Channel Read	supabase.from("user_channel_reads").upsert({ … }, { onConflict: ["user_id","channel_id"] })	Inserts or updates last_read_at.

Third-Party Integration Guidelines
At MVP stage, no third-party AI integrations are implemented. Below guidelines apply when adding AI features (Phase 2).

## AI Summary Feature Implementation (Convex + TinyLlama)

### Architecture Overview
```
Frontend (Next.js) → Convex Actions → Local TinyLlama (Ollama) → Structured Summary
```

### Technology Stack
- **Backend**: Convex (replaces Supabase for this feature)
- **AI Engine**: TinyLlama via Ollama (local processing)
- **Data Storage**: Convex built-in database with vector support
- **Security**: Workspace isolation via Convex's built-in auth

### Database Schema (Convex)
```typescript
// Add to convex/schema.ts
summaries: defineTable({
  workspaceId: v.id("workspaces"),
  contextType: v.union(v.literal("thread"), v.literal("channel")),
  contextId: v.string(), // threadId or channelId
  summary: v.string(),
  messageCount: v.number(),
  participantCount: v.number(),
  generatedBy: v.id("members"),
  generatedAt: v.number(),
})
  .index("by_workspace_id", ["workspaceId"])
  .index("by_context", ["workspaceId", "contextType", "contextId"]),
```

### Local AI Setup
```bash
# Install Ollama
curl -fsSL https://ollama.ai/install.sh | sh

# Pull TinyLlama model (~637MB)
ollama pull tinyllama

# Start Ollama server
ollama serve --host localhost --port 11434
```

### Convex Actions Implementation
```typescript
// convex/aiSummary.ts
export const generateThreadSummary = action({
  args: {
    workspaceId: v.id("workspaces"),
    channelId: v.optional(v.id("channels")),
    threadId: v.optional(v.id("messages")),
    timeRange: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // 1. Verify user permissions
    const userId = await getAuthUserId(ctx);
    const member = await getMember(ctx, args.workspaceId, userId);
    
    // 2. Aggregate messages with workspace isolation
    const messages = await aggregateMessages(ctx, args);
    
    // 3. Build context with user names and timestamps
    const context = await buildSummaryContext(ctx, messages);
    
    // 4. Call local TinyLlama via HTTP
    const summary = await callTinyLlama(context);
    
    // 5. Cache summary in Convex database
    await ctx.runMutation(internal.summaries.create, {
      workspaceId: args.workspaceId,
      contextType: args.threadId ? "thread" : "channel",
      contextId: args.threadId || args.channelId,
      summary: summary.text,
      messageCount: messages.length,
      participantCount: summary.participantCount,
      generatedBy: member._id,
    });
    
    return summary;
  }
});
```

### TinyLlama Integration
```typescript
// HTTP call to local Ollama server
const callTinyLlama = async (context: string) => {
  const response = await fetch('http://localhost:11434/api/generate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      model: 'tinyllama',
      prompt: buildSummaryPrompt(context),
      stream: false,
      options: {
        temperature: 0.3, // More focused responses
        top_p: 0.9,
        max_tokens: 500
      }
    })
  });
  
  if (!response.ok) {
    throw new Error(`TinyLlama API error: ${response.status}`);
  }
  
  const result = await response.json();
  return parseSummaryResponse(result.response);
};
```

### Security & Workspace Isolation
- **Convex Auth**: Built-in user authentication and authorization
- **Workspace Filtering**: All queries automatically filtered by workspaceId
- **Local Processing**: TinyLlama runs locally, no data leaves your infrastructure
- **Permission Checks**: Verify user membership before processing

### Error Handling
```typescript
// Fallback when TinyLlama is unavailable
const generateFallbackSummary = (messages: Message[]) => ({
  summary: "AI summarization temporarily unavailable. Please try again later.",
  participants: extractParticipants(messages),
  messageCount: messages.length,
  keyPoints: [],
  actionItems: [],
  decisions: []
});
```

### Performance Considerations
- **Message Limits**: Process max 500 messages per summary
- **Concurrent Requests**: Limit to 2-3 simultaneous summaries
- **Caching**: Store summaries in Convex for 24 hours
- **Resource Usage**: TinyLlama requires 2-4GB RAM

### Monitoring & Logging
```typescript
// Log AI requests for monitoring
await ctx.runMutation(internal.logs.create, {
  workspaceId: args.workspaceId,
  action: "ai_summary",
  messageCount: messages.length,
  processingTime: Date.now() - startTime,
  success: true
});
```

LLM Provider (e.g., OpenAI, Anthropic)

Never expose API keys to the client. All calls must go through a secure Edge Function or serverless proxy that:

Verifies workspace_id belongs to the authenticated auth.uid().

Queries any vector store or document store (filtered by workspace_id) to build context.

Sends the combined prompt/context to the LLM, using the SERVICE_ROLE_KEY to retrieve protected data if needed.

Returns a structured JSON to the frontend (e.g., { summary: "...", sources: [ { channel: "...", timestamp: "..." } ] }).

Vector Store (for embeddings / RAG)

Option A: Enable and use Supabase's pgvector extension (if on a tier that supports it).

Option B: Spin up a dedicated vector-DB (Pinecone, Weaviate).

Requirement: All embeddings or documents must include workspace_id metadata. During retrieval, always filter by workspace_id to prevent cross-workspace leakage.

OCR / Text Extraction (for PDF attachments)

Implement a serverless function triggered on a new file upload to:

Download the PDF from Supabase Storage.

Run OCR or text extraction (e.g., Tesseract.js or a small Python Lambda).

Insert extracted text into a documents table (fields: id, workspace_id, channel_id, message_id, text, created_at).

Use that text as part of the RAG index.

Monitoring & Logging

When adding AI endpoints, log each request with workspace_id, endpoint, request_time, and response_time.

Integrate Sentry (or your preferred APM) for error tracking in Edge Functions.

Security Measures (Summary)
RLS Policies

Enforce workspace_id matching for every table.

For tables referencing user_id, also ensure user_id = SELECT id FROM users WHERE auth_id = auth.uid().

Storage Bucket ACL

Bucket is private.

Files are accessible only via signed URLs, which expire.

Constraints & Validation

All NOT NULL columns enforced in DDL.

Filetype constraint on attachments.filename.

Unique constraints (e.g., (workspace_id, name) on channels).

HTTPS & CORS

Supabase endpoints require HTTPS.

Configure CORS to allow only your frontend origin(s).

Rate Limiting / Throttling

MVP scale: rely on default Supabase limits.

In future, add per-workspace or per-user rate limits in Edge Functions for AI calls.

Appendix: Complete RLS Policy Snippets
sql
Copy
Edit
-- workspaces table RLS
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;
CREATE POLICY insert_workspace ON public.workspaces
  FOR INSERT
  WITH CHECK ( auth.uid() = created_by );
CREATE POLICY select_workspace ON public.workspaces
  FOR SELECT
  USING ( auth.uid() = created_by );

-- users table RLS
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_self_user ON public.users
  FOR SELECT
  USING ( auth.uid() = auth_id );
CREATE POLICY insert_user ON public.users
  FOR INSERT
  WITH CHECK ( auth.uid() = auth_id );
CREATE POLICY update_self_user ON public.users
  FOR UPDATE
  USING ( auth.uid() = auth_id )
  WITH CHECK ( auth.uid() = auth_id );

-- channels table RLS
ALTER TABLE public.channels ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_channels ON public.channels
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_channels ON public.channels
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY update_channels ON public.channels
  FOR UPDATE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  )
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_channels ON public.channels
  FOR DELETE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- messages table RLS
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_messages ON public.messages
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_messages ON public.messages
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY modify_own_messages ON public.messages
  FOR UPDATE, DELETE
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- attachments table RLS
ALTER TABLE public.attachments ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_attachments ON public.attachments
  FOR SELECT
  USING (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY insert_attachments ON public.attachments
  FOR INSERT
  WITH CHECK (
    workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    ) AND uploaded_by = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_attachments ON public.attachments
  FOR DELETE
  USING (
    uploaded_by = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );

-- user_channel_reads table RLS
ALTER TABLE public.user_channel_reads ENABLE ROW LEVEL SECURITY;
CREATE POLICY select_reads ON public.user_channel_reads
  FOR SELECT
  USING (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY upsert_reads ON public.user_channel_reads
  FOR INSERT, UPDATE
  WITH CHECK (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )
  );
CREATE POLICY delete_reads ON public.user_channel_reads
  FOR DELETE
  USING (
    user_id = (
      SELECT id FROM public.users WHERE auth_id = auth.uid()
    ) AND workspace_id = (
      SELECT workspace_id FROM public.users WHERE auth_id = auth.uid()
    )

  );